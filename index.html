<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>你的小世界</title>
  <style>
    /* 全局样式重置 */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    /* 页面基础配置：允许纵向滚动 */
    html,
    body {
      width: 100%;
      height: 100%;
      overflow-x: hidden;
      scroll-behavior: smooth;
      background: #0f0c29;
      /* 最底层的深色背景 */
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif;
      position: relative;
    }

    /* ========== particles.js 容器样式 ========== */
    #particles-js {
      position: fixed;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      z-index: 0;
      /* 关键：放在背景和内容之间 */
    }

    /* ========== 第一页：极光风格渐变背景（半透明，透出粒子） ========== */
    .hero {
      width: 100%;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 10%;
      gap: 5%;
      position: relative;
      z-index: 1;
      /* 内容在粒子上层 */
      /* 核心修改：所有颜色后面加了 alpha 透明度 (0.7-0.8)，让粒子透出来 */
      background: linear-gradient(-45deg,
          rgba(15, 12, 41, 0.8),
          rgba(48, 43, 99, 0.8),
          rgba(36, 36, 62, 0.8),
          rgba(102, 126, 234, 0.7),
          rgba(118, 75, 162, 0.7),
          rgba(240, 147, 251, 0.6),
          rgba(79, 172, 254, 0.6),
          rgba(0, 242, 254, 0.5),
          rgba(168, 237, 234, 0.5));
      background-size: 400% 400%;
      animation: auroraFlow 12s ease-in-out infinite;
    }

    /* 极光流动动画 */
    @keyframes auroraFlow {
      0% {
        background-position: 0% 50%;
      }

      25% {
        background-position: 50% 100%;
      }

      50% {
        background-position: 100% 50%;
      }

      75% {
        background-position: 50% 0%;
      }

      100% {
        background-position: 0% 50%;
      }
    }

    /* 元素通用入场动画 */
    @keyframes scaleIn {
      0% {
        opacity: 0;
        transform: scale(0.6);
      }

      100% {
        opacity: 1;
        transform: scale(1);
      }
    }

    /* 左侧文字内容容器 - 居中排版 */
    .content {
      flex: 1;
      color: #fff;
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    /* 英文标题样式+入场动画 */
    .en-title {
      font-size: clamp(3rem, 8vw, 6rem);
      font-weight: 600;
      line-height: 1.1;
      margin-bottom: 1rem;
      animation: scaleIn 0.8s ease-out forwards;
      opacity: 0;
    }

    /* 中文标题样式+入场动画 */
    .cn-title {
      font-size: clamp(2rem, 5vw, 4rem);
      font-weight: 900;
      letter-spacing: 0.2em;
      line-height: 1.2;
      margin-bottom: 2.5rem;
      animation: scaleIn 0.8s ease-out 0.2s forwards;
      opacity: 0;
    }

    /* 描述文本样式+入场动画 */
    .desc {
      font-size: clamp(1rem, 2vw, 1.25rem);
      line-height: 1.8;
      max-width: 600px;
      margin-bottom: 3.5rem;
      animation: scaleIn 0.8s ease-out 0.4s forwards;
      opacity: 0;
    }

    /* 温暖文案样式 */
    .warm-text {
      font-size: clamp(1.1rem, 2.2vw, 1.4rem);
      line-height: 2.2;
      color: #e2e8f0;
      animation: scaleIn 0.8s ease-out 0.6s forwards;
      opacity: 0;
    }

    /* 右侧图片容器 */
    .image-wrapper {
      flex: 0 0 40%;
      border: 8px solid #fff;
      animation: scaleIn 0.8s ease-out 0.3s forwards;
      opacity: 0;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    }

    .image-wrapper img {
      width: 100%;
      height: auto;
      display: block;
      object-fit: cover;
    }

    /* ========== 第二页：极光风格背景 + 白色字体（半透明，透出粒子） ========== */
    .interaction {
      position: relative;
      width: 100%;
      min-height: 100vh;
      /* 核心修改：背景改成半透明 */
      background: linear-gradient(135deg,
          rgba(15, 12, 41, 0.85),
          rgba(48, 43, 99, 0.85),
          rgba(102, 126, 234, 0.8),
          rgba(118, 75, 162, 0.8),
          rgba(240, 147, 251, 0.75));
      background-size: 300% 300%;
      animation: auroraFlow 15s ease-in-out infinite;
      padding: 4rem 10%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1;
      /* 内容在粒子上层 */
    }

    /* 选项容器 */
    .options-container {
      width: 100%;
      max-width: 500px;
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      transition: all 0.5s ease-out;
    }

    .options-container.hide {
      opacity: 0;
      transform: translateY(20px);
      pointer-events: none;
      display: none;
    }

    /* 选项按钮 - 白色字体 + 半透明背景 */
    .option-btn {
      padding: 1.2rem 1.5rem;
      border: 1px solid rgba(255, 255, 255, 0.3);
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      font-size: 1.1rem;
      line-height: 1.5;
      color: #fff;
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: left;
      opacity: 0;
      transform: translateY(-20px);
    }

    .option-btn.visible {
      opacity: 1;
      transform: translateY(0);
    }

    .option-btn:hover {
      border-color: rgba(255, 255, 255, 0.6);
      background: rgba(255, 255, 255, 0.2);
      transform: translateY(-2px);
      box-shadow: 0 4px 20px rgba(255, 255, 255, 0.1);
    }

    /* 回复区域 */
    .reply-container {
      width: 100%;
      max-width: 500px;
      text-align: center;
      display: none;
      opacity: 0;
      transform: scale(0.6);
      transition: all 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    .reply-container.show {
      display: block;
      opacity: 1;
      transform: scale(1);
    }

    .reply-text {
      font-size: 1.3rem;
      line-height: 1.8;
      color: #fff;
    }

    /* 底部小字 - 浅白色 */
    .footer-text {
      position: absolute;
      bottom: 2rem;
      left: 50%;
      transform: translateX(-50%);
      font-size: 0.9rem;
      color: #e2e8f0;
      text-align: center;
      max-width: 80%;
      line-height: 1.6;
    }

    /* 移动端响应式适配 */
    @media (max-width: 768px) {
      .hero {
        flex-direction: column;
        justify-content: center;
        padding: 5%;
        gap: 2rem;
        height: auto;
        min-height: 100vh;
        overflow-y: auto;
      }

      .cn-title {
        letter-spacing: 0.1em;
      }

      .image-wrapper {
        width: 80%;
        flex: none;
      }

      .interaction {
        padding: 3rem 8%;
      }

      .option-btn {
        text-align: center;
      }
    }
  </style>
</head>

<body>
  <!-- particles.js 容器 -->
  <div id="particles-js"></div>

  <!-- 第一屏：首页内容 -->
  <div class="hero">
    <div class="content">
      <h1 class="en-title">NiceToMeetYou</h1>
      <h2 class="cn-title">Hi,今日好</h2>
      <p class="desc" id="dynamic-text"></p>
      <p class="warm-text">
        打开这个网页的时候，就当我抱了抱你<br>
        希望你一切都好<br>
        好好吃饭，好好睡觉
      </p>
    </div>

    <!-- 右侧图片 -->
    <div class="image-wrapper">
      <img src="cat.jpg" alt="小猫照片">
    </div>
  </div>

  <!-- 第二屏：互动页 -->
  <section class="interaction" id="interaction">
    <div class="options-container" id="optionsContainer">
      <button class="option-btn" data-type="happy">如果你今天很开心 / 遇到了好事</button>
      <button class="option-btn" data-type="chill">如果你只是摸鱼随便逛逛</button>
      <button class="option-btn" data-type="tired">如果你现在有点累 / 有点烦</button>
      <button class="option-btn" data-type="struggle">如果你又在跟自己较劲 / 绷着神经</button>
    </div>

    <div class="reply-container" id="replyContainer">
      <p class="reply-text" id="replyText"></p>
    </div>

    <p class="footer-text" id="footerText"></p>
  </section>

  <!-- 内嵌 particles.js 代码 -->
  <script>
    var pJS = function (e, t) { var i = document.querySelector("#" + e + " > .particles-js-canvas-el"); this.pJS = { canvas: { el: i, w: i.offsetWidth, h: i.offsetHeight }, particles: { number: { value: 400, density: { enable: !0, value_area: 800 } }, color: { value: "#fff" }, shape: { type: "circle", stroke: { width: 0, color: "#ff0000" }, polygon: { nb_sides: 5 }, image: { src: "", width: 100, height: 100 } }, opacity: { value: 1, random: !1, anim: { enable: !1, speed: 2, opacity_min: 0, sync: !1 } }, size: { value: 20, random: !1, anim: { enable: !1, speed: 20, size_min: 0, sync: !1 } }, line_linked: { enable: !0, distance: 100, color: "#fff", opacity: 1, width: 1 }, move: { enable: !0, speed: 2, direction: "none", random: !1, straight: !1, out_mode: "out", bounce: !1, attract: { enable: !1, rotateX: 3e3, rotateY: 3e3 } }, array: [] }, interactivity: { detect_on: "canvas", events: { onhover: { enable: !0, mode: "grab" }, onclick: { enable: !0, mode: "push" }, resize: !0 }, modes: { grab: { distance: 100, line_linked: { opacity: 1 } }, bubble: { distance: 200, size: 80, duration: .4 }, repulse: { distance: 200, duration: .4 }, push: { particles_nb: 4 }, remove: { particles_nb: 2 } }, mouse: {} }, retina_detect: !1, fn: { interact: {}, modes: {}, vendors: {} }, tmp: {} }; var s = this.pJS; t && Object.deepExtend(s, t), s.tmp.obj = { size_value: s.particles.size.value, size_anim_speed: s.particles.size.anim.speed, move_speed: s.particles.move.speed, line_linked_distance: s.particles.line_linked.distance, line_linked_width: s.particles.line_linked.width, mode_grab_distance: s.interactivity.modes.grab.distance, mode_bubble_distance: s.interactivity.modes.bubble.distance, mode_bubble_size: s.interactivity.modes.bubble.size, mode_repulse_distance: s.interactivity.modes.repulse.distance }, s.fn.retinaInit = function () { s.retina_detect && window.devicePixelRatio > 1 ? (s.canvas.pxratio = window.devicePixelRatio, s.tmp.retina = !0) : (s.canvas.pxratio = 1, s.tmp.retina = !1), s.canvas.w = s.canvas.el.offsetWidth * s.canvas.pxratio, s.canvas.h = s.canvas.el.offsetHeight * s.canvas.pxratio, s.particles.size.value = s.tmp.obj.size_value * s.canvas.pxratio, s.particles.size.anim.speed = s.tmp.obj.size_anim_speed * s.canvas.pxratio, s.particles.move.speed = s.tmp.obj.move_speed * s.canvas.pxratio, s.particles.line_linked.distance = s.tmp.obj.line_linked_distance * s.canvas.pxratio, s.interactivity.modes.grab.distance = s.tmp.obj.mode_grab_distance * s.canvas.pxratio, s.interactivity.modes.bubble.distance = s.tmp.obj.mode_bubble_distance * s.canvas.pxratio, s.particles.line_linked.width = s.tmp.obj.line_linked_width * s.canvas.pxratio, s.interactivity.modes.bubble.size = s.tmp.obj.mode_bubble_size * s.canvas.pxratio, s.interactivity.modes.repulse.distance = s.tmp.obj.mode_repulse_distance * s.canvas.pxratio }, s.fn.canvasInit = function () { s.canvas.ctx = s.canvas.el.getContext("2d") }, s.fn.canvasSize = function () { s.canvas.el.width = s.canvas.w, s.canvas.el.height = s.canvas.h, s && s.interactivity.events.resize && window.addEventListener("resize", (function () { s.canvas.w = s.canvas.el.offsetWidth, s.canvas.h = s.canvas.el.offsetHeight, s.tmp.retina && (s.canvas.w *= s.canvas.pxratio, s.canvas.h *= s.canvas.pxratio), s.canvas.el.width = s.canvas.w, s.canvas.el.height = s.canvas.h, s.particles.move.enable || (s.fn.particlesEmpty(), s.fn.particlesCreate(), s.fn.particlesDraw(), s.fn.vendors.densityAutoParticles()), s.fn.vendors.densityAutoParticles() })) }, s.fn.canvasPaint = function () { s.canvas.ctx.fillRect(0, 0, s.canvas.w, s.canvas.h) }, s.fn.canvasClear = function () { s.canvas.ctx.clearRect(0, 0, s.canvas.w, s.canvas.h) }, s.fn.particle = function (e, t, i) { if (this.radius = (s.particles.size.random ? Math.random() : 1) * s.particles.size.value, s.particles.size.anim.enable && (this.size_status = !1, this.vs = s.particles.size.anim.speed / 100, s.particles.size.anim.sync || (this.vs = this.vs * Math.random())), this.x = i ? i.x : Math.random() * s.canvas.w, this.y = i ? i.y : Math.random() * s.canvas.h, this.x > s.canvas.w - 2 * this.radius ? this.x = this.x - this.radius : this.x < 2 * this.radius && (this.x = this.x + this.radius), this.y > s.canvas.h - 2 * this.radius ? this.y = this.y - this.radius : this.y < 2 * this.radius && (this.y = this.y + this.radius), s.particles.move.bounce && s.fn.vendors.checkOverlap(this, i), this.color = {}, "object" == typeof e.value) if (e.value instanceof Array) { var n = e.value[Math.floor(Math.random() * s.particles.color.value.length)]; this.color.rgb = hexToRgb(n) } else null != e.value.r && null != e.value.g && null != e.value.b && (this.color.rgb = { r: e.value.r, g: e.value.g, b: e.value.b }), null != e.value.h && null != e.value.s && null != e.value.l && (this.color.hsl = { h: e.value.h, s: e.value.s, l: e.value.l }); else "random" == e.value ? this.color.rgb = { r: Math.floor(256 * Math.random()) + 0, g: Math.floor(256 * Math.random()) + 0, b: Math.floor(256 * Math.random()) + 0 } : "string" == typeof e.value && (this.color = e, this.color.rgb = hexToRgb(this.color.value)); this.opacity = (s.particles.opacity.random ? Math.random() : 1) * s.particles.opacity.value, s.particles.opacity.anim.enable && (this.opacity_status = !1, this.vo = s.particles.opacity.anim.speed / 100, s.particles.opacity.anim.sync || (this.vo = this.vo * Math.random())); var a = {}; switch (s.particles.move.direction) { case "top": a = { x: 0, y: -1 }; break; case "top-right": a = { x: .5, y: -.5 }; break; case "right": a = { x: 1, y: -0 }; break; case "bottom-right": a = { x: .5, y: .5 }; break; case "bottom": a = { x: 0, y: 1 }; break; case "bottom-left": a = { x: -.5, y: 1 }; break; case "left": a = { x: -1, y: 0 }; break; case "top-left": a = { x: -.5, y: -.5 }; break; default: a = { x: 0, y: 0 } }s.particles.move.straight ? (this.vx = a.x, this.vy = a.y, s.particles.move.random && (this.vx = this.vx * Math.random(), this.vy = this.vy * Math.random())) : (this.vx = a.x + Math.random() - .5, this.vy = a.y + Math.random() - .5), this.vx_i = this.vx, this.vy_i = this.vy; var r = s.particles.shape.type; if ("object" == typeof r) { if (r instanceof Array) { var c = r[Math.floor(Math.random() * r.length)]; this.shape = c } } else this.shape = r; if ("image" == this.shape) { var o = s.particles.shape; this.img = { src: o.image.src, ratio: o.image.width / o.image.height }, this.img.ratio || (this.img.ratio = 1), "svg" == s.tmp.img_type && null != s.tmp.source_svg && (s.fn.vendors.createSvgImg(this), s.tmp.pushing && (this.img.loaded = !1)) } }, s.fn.particle.prototype.draw = function () { var e = this; if (null != e.radius_bubble) var t = e.radius_bubble; else t = e.radius; if (null != e.opacity_bubble) var i = e.opacity_bubble; else i = e.opacity; if (e.color.rgb) var n = "rgba(" + e.color.rgb.r + "," + e.color.rgb.g + "," + e.color.rgb.b + "," + i + ")"; else n = "hsla(" + e.color.hsl.h + "," + e.color.hsl.s + "%," + e.color.hsl.l + "%," + i + ")"; switch (s.canvas.ctx.fillStyle = n, s.canvas.ctx.beginPath(), e.shape) { case "circle": s.canvas.ctx.arc(e.x, e.y, t, 0, 2 * Math.PI, !1); break; case "edge": s.canvas.ctx.rect(e.x - t, e.y - t, 2 * t, 2 * t); break; case "triangle": s.fn.vendors.drawShape(s.canvas.ctx, e.x - t, e.y + t / 1.66, 2 * t, 3, 2); break; case "polygon": s.fn.vendors.drawShape(s.canvas.ctx, e.x - t / (s.particles.shape.polygon.nb_sides / 3.5), e.y - t / .76, 2.66 * t / (s.particles.shape.polygon.nb_sides / 3), s.particles.shape.polygon.nb_sides, 1); break; case "star": s.fn.vendors.drawShape(s.canvas.ctx, e.x - 2 * t / (s.particles.shape.polygon.nb_sides / 4), e.y - t / 1.52, 2 * t * 2.66 / (s.particles.shape.polygon.nb_sides / 3), s.particles.shape.polygon.nb_sides, 2); break; case "image": if ("svg" == s.tmp.img_type) var a = e.img.obj; else a = s.tmp.img_obj; a && s.canvas.ctx.drawImage(a, e.x - t, e.y - t, 2 * t, 2 * t / e.img.ratio) }s.canvas.ctx.closePath(), s.particles.shape.stroke.width > 0 && (s.canvas.ctx.strokeStyle = s.particles.shape.stroke.color, s.canvas.ctx.lineWidth = s.particles.shape.stroke.width, s.canvas.ctx.stroke()), s.canvas.ctx.fill() }, s.fn.particlesCreate = function () { for (var e = 0; e < s.particles.number.value; e++)s.particles.array.push(new s.fn.particle(s.particles.color, s.particles.opacity.value)) }, s.fn.particlesUpdate = function () { for (var e = 0; e < s.particles.array.length; e++) { var t = s.particles.array[e]; if (s.particles.move.enable) { var i = s.particles.move.speed / 2; t.x += t.vx * i, t.y += t.vy * i } if (s.particles.opacity.anim.enable && (1 == t.opacity_status ? (t.opacity >= s.particles.opacity.value && (t.opacity_status = !1), t.opacity += t.vo) : (t.opacity <= s.particles.opacity.anim.opacity_min && (t.opacity_status = !0), t.opacity -= t.vo), t.opacity < 0 && (t.opacity = 0)), s.particles.size.anim.enable && (1 == t.size_status ? (t.radius >= s.particles.size.value && (t.size_status = !1), t.radius += t.vs) : (t.radius <= s.particles.size.anim.size_min && (t.size_status = !0), t.radius -= t.vs), t.radius < 0 && (t.radius = 0)), "bounce" == s.particles.move.out_mode) var n = { x_left: t.radius, x_right: s.canvas.w, y_top: t.radius, y_bottom: s.canvas.h }; else n = { x_left: -t.radius, x_right: s.canvas.w + t.radius, y_top: -t.radius, y_bottom: s.canvas.h + t.radius }; if (t.x - t.radius > s.canvas.w ? (t.x = n.x_left, t.y = Math.random() * s.canvas.h) : t.x + t.radius < 0 && (t.x = n.x_right, t.y = Math.random() * s.canvas.h), t.y - t.radius > s.canvas.h ? (t.y = n.y_top, t.x = Math.random() * s.canvas.w) : t.y + t.radius < 0 && (t.y = n.y_bottom, t.x = Math.random() * s.canvas.h), "bounce" === s.particles.move.out_mode) (t.x + t.radius > s.canvas.w || t.x - t.radius < 0) && (t.vx = -t.vx), (t.y + t.radius > s.canvas.h || t.y - t.radius < 0) && (t.vy = -t.vy); if (isInArray("grab", s.interactivity.events.onhover.mode) && s.fn.modes.grabParticle(t), (isInArray("bubble", s.interactivity.events.onhover.mode) || isInArray("bubble", s.interactivity.events.onclick.mode)) && s.fn.modes.bubbleParticle(t), (isInArray("repulse", s.interactivity.events.onhover.mode) || isInArray("repulse", s.interactivity.events.onclick.mode)) && s.fn.modes.repulseParticle(t), s.particles.line_linked.enable || s.particles.move.attract.enable) for (var a = e + 1; a < s.particles.array.length; a++) { var r = s.particles.array[a]; s.particles.line_linked.enable && s.fn.interact.linkParticles(t, r), s.particles.move.attract.enable && s.fn.interact.attractParticles(t, r), s.particles.move.bounce && s.fn.interact.bounceParticles(t, r) } } }, s.fn.particlesDraw = function () { s.canvas.ctx.clearRect(0, 0, s.canvas.w, s.canvas.h), s.fn.particlesUpdate(); for (var e = 0; e < s.particles.array.length; e++) { s.particles.array[e].draw() } }, s.fn.particlesEmpty = function () { s.particles.array = [] }, s.fn.particlesRefresh = function () { cancelRequestAnimFrame(s.fn.checkAnimFrame), cancelRequestAnimFrame(s.fn.drawAnimFrame), s.tmp.source_svg = void 0, s.tmp.img_obj = void 0, s.tmp.count_svg = 0, s.fn.particlesEmpty(), s.fn.canvasClear(), s.fn.vendors.start() }, s.fn.interact.linkParticles = function (e, t) { var i = e.x - t.x, n = e.y - t.y, a = Math.sqrt(i * i + n * n); if (a <= s.particles.line_linked.distance) { var r = s.particles.line_linked.opacity - a / (1 / s.particles.line_linked.opacity) / s.particles.line_linked.distance; if (r > 0) { var c = s.particles.line_linked.color_rgb_line; s.canvas.ctx.strokeStyle = "rgba(" + c.r + "," + c.g + "," + c.b + "," + r + ")", s.canvas.ctx.lineWidth = s.particles.line_linked.width, s.canvas.ctx.beginPath(), s.canvas.ctx.moveTo(e.x, e.y), s.canvas.ctx.lineTo(t.x, t.y), s.canvas.ctx.stroke(), s.canvas.ctx.closePath() } } }, s.fn.interact.attractParticles = function (e, t) { var i = e.x - t.x, n = e.y - t.y; if (Math.sqrt(i * i + n * n) <= s.particles.line_linked.distance) { var a = i / (1e3 * s.particles.move.attract.rotateX), r = n / (1e3 * s.particles.move.attract.rotateY); e.vx -= a, e.vy -= r, t.vx += a, t.vy += r } }, s.fn.interact.bounceParticles = function (e, t) { var i = e.x - t.x, n = e.y - t.y; Math.sqrt(i * i + n * n) <= e.radius + t.radius && (e.vx = -e.vx, e.vy = -e.vy, t.vx = -t.vx, t.vy = -t.vy) }, s.fn.modes.pushParticles = function (e, t) { s.tmp.pushing = !0; for (var i = 0; i < e; i++)s.particles.array.push(new s.fn.particle(s.particles.color, s.particles.opacity.value, { x: t ? t.pos_x : Math.random() * s.canvas.w, y: t ? t.pos_y : Math.random() * s.canvas.h })), i == e - 1 && (s.particles.move.enable || s.fn.particlesDraw(), s.tmp.pushing = !1) }, s.fn.modes.removeParticles = function (e) { s.particles.array.splice(0, e), s.particles.move.enable || s.fn.particlesDraw() }, s.fn.modes.bubbleParticle = function (e) { if (s.interactivity.events.onhover.enable && isInArray("bubble", s.interactivity.events.onhover.mode)) { var t = e.x - s.interactivity.mouse.pos_x, i = e.y - s.interactivity.mouse.pos_y, n = 1 - (a = Math.sqrt(t * t + i * i)) / s.interactivity.modes.bubble.distance; function a() { e.opacity_bubble = e.opacity, e.radius_bubble = e.radius } if (a <= s.interactivity.modes.bubble.distance) { if (n >= 0 && "mousemove" == s.interactivity.status) { if (s.interactivity.modes.bubble.size != s.particles.size.value) if (s.interactivity.modes.bubble.size > s.particles.size.value) { (r = e.radius + s.interactivity.modes.bubble.size * n) >= 0 && (e.radius_bubble = r) } else { var r = e.radius - s.interactivity.modes.bubble.size, c = e.radius - r * n; e.radius_bubble = c > 0 ? c : 0 } var o; if (s.interactivity.modes.bubble.opacity != s.particles.opacity.value) if (s.interactivity.modes.bubble.opacity > s.particles.opacity.value) (o = s.interactivity.modes.bubble.opacity * n) > e.opacity && o <= s.interactivity.modes.bubble.opacity && (e.opacity_bubble = o); else (o = e.opacity - (s.particles.opacity.value - s.interactivity.modes.bubble.opacity) * n) < e.opacity && o >= s.interactivity.modes.bubble.opacity && (e.opacity_bubble = o) } } else a(); "mouseleave" == s.interactivity.status && a() } else if (s.interactivity.events.onclick.enable && isInArray("bubble", s.interactivity.events.onclick.mode)) { if (s.tmp.bubble_clicking) { t = e.x - s.interactivity.mouse.click_pos_x, i = e.y - s.interactivity.mouse.click_pos_y; var a = Math.sqrt(t * t + i * i), o = ((new Date).getTime() - s.interactivity.mouse.click_time) / 1e3; o > s.interactivity.modes.bubble.duration && (s.tmp.bubble_duration_end = !0), o > 2 * s.interactivity.modes.bubble.duration && (s.tmp.bubble_clicking = !1, s.tmp.bubble_duration_end = !1) } function l(e, t, i, n, a) { if (e != t) if (s.tmp.bubble_duration_end) null != i && (r = e + (e - (n - o * (n - e) / s.interactivity.modes.bubble.duration)), "size" == a && (e.radius_bubble = r), "opacity" == a && (e.opacity_bubble = r)); else if (a <= s.interactivity.modes.bubble.distance) { if (null != i) var r = i; else r = n; if (r != e) { var r = n - o * (n - e) / s.interactivity.modes.bubble.duration; "size" == a && (e.radius_bubble = r), "opacity" == a && (e.opacity_bubble = r) } } else "size" == a && (e.radius_bubble = void 0), "opacity" == a && (e.opacity_bubble = void 0) } s.tmp.bubble_clicking && (l(s.interactivity.modes.bubble.size, s.particles.size.value, e.radius_bubble, e.radius, "size"), l(s.interactivity.modes.bubble.opacity, s.particles.opacity.value, e.opacity_bubble, e.opacity, "opacity")) } }, s.fn.modes.repulseParticle = function (e) { if (s.interactivity.events.onhover.enable && isInArray("repulse", s.interactivity.events.onhover.mode) && "mousemove" == s.interactivity.status) { var t = e.x - s.interactivity.mouse.pos_x, i = e.y - s.interactivity.mouse.pos_y, n = Math.sqrt(t * t + i * i), a = { x: t / n, y: i / n }, r = clamp(1 / (o = s.interactivity.modes.repulse.distance) * (-1 * Math.pow(n / o, 2) + 1) * o * 100, 0, 50), c = { x: e.x + a.x * r, y: e.y + a.y * r }; "bounce" == s.particles.move.out_mode ? (c.x - e.radius > 0 && c.x + e.radius < s.canvas.w && (e.x = c.x), c.y - e.radius > 0 && c.y + e.radius < s.canvas.h && (e.y = c.y)) : (e.x = c.x, e.y = c.y) } else if (s.interactivity.events.onclick.enable && isInArray("repulse", s.interactivity.events.onclick.mode)) if (s.tmp.repulse_finish || (s.tmp.repulse_count++, s.tmp.repulse_count == s.particles.array.length && (s.tmp.repulse_finish = !0)), s.tmp.repulse_clicking) { var o = Math.pow(s.interactivity.modes.repulse.distance / 6, 3), l = e.x - s.interactivity.mouse.click_pos_x, p = e.y - s.interactivity.mouse.click_pos_y, d = l * l + p * p, u = -o / d * 1; d <= o && function () { var t = Math.atan2(p, l); if (e.vx = u * Math.cos(t), e.vy = u * Math.sin(t), "bounce" == s.particles.move.out_mode) { var i = { x: e.x + e.vx, y: e.y + e.vy }; (i.x + e.radius > s.canvas.w || i.x - e.radius < 0) && (e.vx = -e.vx), (i.y + e.radius > s.canvas.h || i.y - e.radius < 0) && (e.vy = -e.vy) } }() } else 0 == s.tmp.repulse_clicking && (e.vx = e.vx_i, e.vy = e.vy_i) }, s.fn.modes.grabParticle = function (e) { if (s.interactivity.events.onhover.enable && "mousemove" == s.interactivity.status) { var t = e.x - s.interactivity.mouse.pos_x, i = e.y - s.interactivity.mouse.pos_y, n = Math.sqrt(t * t + i * i); if (n <= s.interactivity.modes.grab.distance) { var a = s.interactivity.modes.grab.line_linked.opacity - n / (1 / s.interactivity.modes.grab.line_linked.opacity) / s.interactivity.modes.grab.distance; if (a > 0) { var r = s.particles.line_linked.color_rgb_line; s.canvas.ctx.strokeStyle = "rgba(" + r.r + "," + r.g + "," + r.b + "," + a + ")", s.canvas.ctx.lineWidth = s.particles.line_linked.width, s.canvas.ctx.beginPath(), s.canvas.ctx.moveTo(e.x, e.y), s.canvas.ctx.lineTo(s.interactivity.mouse.pos_x, s.interactivity.mouse.pos_y), s.canvas.ctx.stroke(), s.canvas.ctx.closePath() } } } }, s.fn.vendors.eventsListeners = function () { "window" == s.interactivity.detect_on ? s.interactivity.el = window : s.interactivity.el = s.canvas.el, (s.interactivity.events.onhover.enable || s.interactivity.events.onclick.enable) && (s.interactivity.el.addEventListener("mousemove", (function (e) { if (s.interactivity.el == window) var t = e.clientX, i = e.clientY; else t = e.offsetX || e.clientX, i = e.offsetY || e.clientY; s.interactivity.mouse.pos_x = t, s.interactivity.mouse.pos_y = i, s.tmp.retina && (s.interactivity.mouse.pos_x *= s.canvas.pxratio, s.interactivity.mouse.pos_y *= s.canvas.pxratio), s.interactivity.status = "mousemove" })), s.interactivity.el.addEventListener("mouseleave", (function (e) { s.interactivity.mouse.pos_x = null, s.interactivity.mouse.pos_y = null, s.interactivity.status = "mouseleave" }))), s.interactivity.events.onclick.enable && s.interactivity.el.addEventListener("click", (function () { if (s.interactivity.mouse.click_pos_x = s.interactivity.mouse.pos_x, s.interactivity.mouse.click_pos_y = s.interactivity.mouse.pos_y, s.interactivity.mouse.click_time = (new Date).getTime(), s.interactivity.events.onclick.enable) switch (s.interactivity.events.onclick.mode) { case "push": s.particles.move.enable || 1 == s.interactivity.modes.push.particles_nb ? s.fn.modes.pushParticles(s.interactivity.modes.push.particles_nb, s.interactivity.modes) : s.interactivity.modes.push.particles_nb > 1 && s.fn.modes.pushParticles(s.interactivity.modes.push.particles_nb); break; case "remove": s.fn.modes.removeParticles(s.interactivity.modes.remove.particles_nb); break; case "bubble": s.tmp.bubble_clicking = !0; break; case "repulse": s.tmp.repulse_clicking = !0, s.tmp.repulse_count = 0, s.tmp.repulse_finish = !1, setTimeout((function () { s.tmp.repulse_clicking = !1 }), 1e3 * s.interactivity.modes.repulse.duration) } })) }, s.fn.vendors.densityAutoParticles = function () { if (s.particles.number.density.enable) { var e = s.canvas.el.width * s.canvas.el.height / 1e3; s.tmp.retina && (e /= 2 * s.canvas.pxratio); var t = e * s.particles.number.value / s.particles.number.density.value_area, i = s.particles.array.length - t; i < 0 ? s.fn.modes.pushParticles(Math.abs(i)) : s.fn.modes.removeParticles(i) } }, s.fn.vendors.checkOverlap = function (e, t) { for (var i = 0; i < s.particles.array.length; i++) { var n = s.particles.array[i], a = e.x - n.x, r = e.y - n.y; Math.sqrt(a * a + r * r) <= e.radius + n.radius && (e.x = t ? t.x : Math.random() * s.canvas.w, e.y = t ? t.y : Math.random() * s.canvas.h, s.fn.vendors.checkOverlap(e, t)) } }, s.fn.vendors.createSvgImg = function (e) { var t = s.tmp.source_svg.replace(/#([0-9A-F]{3,6})/gi, (function (t, i, n, s) { if (e.color.rgb) var a = "rgba(" + e.color.rgb.r + "," + e.color.rgb.g + "," + e.color.rgb.b + "," + e.opacity + ")"; else a = "hsla(" + e.color.hsl.h + "," + e.color.hsl.s + "%," + e.color.hsl.l + "%," + e.opacity + ")"; return a })), i = new Blob([t], { type: "image/svg+xml;charset=utf-8" }), n = window.URL || window.webkitURL || window, a = n.createObjectURL(i), r = new Image; r.addEventListener("load", (function () { e.img.obj = r, e.img.loaded = !0, n.revokeObjectURL(a), s.tmp.count_svg++ })), r.src = a }, s.fn.vendors.destroypJS = function () { cancelAnimationFrame(s.fn.drawAnimFrame), i.remove(), pJSDom = null }, s.fn.vendors.drawShape = function (e, t, i, n, a, r) { var c = a * r, o = a / r, l = 180 * (o - 2) / o, p = Math.PI - Math.PI * l / 180; e.save(), e.beginPath(), e.translate(t, i), e.moveTo(0, 0); for (var d = 0; d < c; d++)e.lineTo(n, 0), e.translate(n, 0), e.rotate(p); e.fill(), e.restore() }, s.fn.vendors.exportImg = function () { window.open(s.canvas.el.toDataURL("image/png"), "_blank") }, s.fn.vendors.loadImg = function (e) { if (s.tmp.img_error = void 0, "" != s.particles.shape.image.src) if ("svg" == e) { var t = new XMLHttpRequest; t.open("GET", s.particles.shape.image.src), t.onreadystatechange = function (e) { 4 == t.readyState && (200 == t.status ? (s.tmp.source_svg = e.currentTarget.response, s.fn.vendors.checkBeforeDraw()) : (console.log("Error pJS - Image not found"), s.tmp.img_error = !0)) }, t.send() } else { var i = new Image; i.addEventListener("load", (function () { s.tmp.img_obj = i, s.fn.vendors.checkBeforeDraw() })), i.src = s.particles.shape.image.src } else console.log("Error pJS - No image.src"), s.tmp.img_error = !0 }, s.fn.vendors.draw = function () { "image" == s.particles.shape.type ? "svg" == s.tmp.img_type ? s.tmp.count_svg >= s.particles.number.value ? (s.fn.particlesDraw(), s.particles.move.enable ? s.fn.drawAnimFrame = requestAnimFrame(s.fn.vendors.draw) : cancelRequestAnimFrame(s.fn.drawAnimFrame)) : s.tmp.img_error || (s.fn.drawAnimFrame = requestAnimFrame(s.fn.vendors.draw)) : null != s.tmp.img_obj ? (s.fn.particlesDraw(), s.particles.move.enable ? s.fn.drawAnimFrame = requestAnimFrame(s.fn.vendors.draw) : cancelRequestAnimFrame(s.fn.drawAnimFrame)) : s.tmp.img_error || (s.fn.drawAnimFrame = requestAnimFrame(s.fn.vendors.draw)) : (s.fn.particlesDraw(), s.particles.move.enable ? s.fn.drawAnimFrame = requestAnimFrame(s.fn.vendors.draw) : cancelRequestAnimFrame(s.fn.drawAnimFrame)) }, s.fn.vendors.checkBeforeDraw = function () { "image" == s.particles.shape.type ? "svg" == s.tmp.img_type && null == s.tmp.source_svg ? s.tmp.checkAnimFrame = requestAnimFrame(check) : (cancelRequestAnimFrame(s.tmp.checkAnimFrame), s.tmp.img_error || (s.fn.vendors.init(), s.fn.vendors.draw())) : (s.fn.vendors.init(), s.fn.vendors.draw()) }, s.fn.vendors.init = function () { s.fn.retinaInit(), s.fn.canvasInit(), s.fn.canvasSize(), s.fn.canvasPaint(), s.fn.particlesCreate(), s.fn.vendors.densityAutoParticles(), s.particles.line_linked.color_rgb_line = hexToRgb(s.particles.line_linked.color) }, s.fn.vendors.start = function () { isInArray("image", s.particles.shape.type) ? (s.tmp.img_type = s.particles.shape.image.src.substr(s.particles.shape.image.src.length - 3), s.fn.vendors.loadImg(s.tmp.img_type)) : s.fn.vendors.checkBeforeDraw() }, s.fn.vendors.eventsListeners(), s.fn.vendors.start() }; function hexToRgb(e) { e = e.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, (function (e, t, i, n) { return t + t + i + i + n + n })); var t = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e); return t ? { r: parseInt(t[1], 16), g: parseInt(t[2], 16), b: parseInt(t[3], 16) } : null } function clamp(e, t, i) { return Math.min(Math.max(e, t), i) } function isInArray(e, t) { return t.indexOf(e) > -1 } Object.deepExtend = function (e, t) { for (var i in t) t[i] && t[i].constructor && t[i].constructor === Object ? (e[i] = e[i] || {}, arguments.callee(e[i], t[i])) : e[i] = t[i]; return e }, window.requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (e) { window.setTimeout(e, 1e3 / 60) }, window.cancelRequestAnimFrame = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame || clearTimeout, window.pJSDom = [], window.particlesJS = function (e, t) { "string" != typeof e && (t = e, e = "particles-js"), e || (e = "particles-js"); var i = document.getElementById(e), s = "particles-js-canvas-el", n = i.getElementsByClassName(s); if (n.length) for (; n.length > 0;)i.removeChild(n[0]); var a = document.createElement("canvas"); a.className = s, a.style.width = "100%", a.style.height = "100%", null != document.getElementById(e).appendChild(a) && pJSDom.push(new pJS(e, t)) }, window.particlesJS.load = function (e, t, i) { var s = new XMLHttpRequest; s.open("GET", t), s.onreadystatechange = function (n) { if (4 == s.readyState) if (200 == s.status) { var a = JSON.parse(n.currentTarget.response); window.particlesJS(e, a), i && i() } else console.log("Error pJS - XMLHttpRequest status: " + s.status), console.log("Error pJS - File config not found") }, s.send() };
  </script>

  <!-- JavaScript：原有功能 + 粒子初始化 -->
  <script>
    // ========== 统一的 window.onload ==========
    window.onload = function () {
      // 1. 初始化粒子效果 (白色粒子，配合极光)
      particlesJS('particles-js', {
        "particles": {
          "number": { "value": 80, "density": { "enable": true, "value_area": 800 } },
          "color": { "value": "#ffffff" }, // 白色粒子
          "shape": { "type": "circle" },
          "opacity": { "value": 0.5 },
          "size": { "value": 3, "random": true },
          "line_linked": { "enable": true, "distance": 150, "color": "#ffffff", "opacity": 0.4, "width": 1 },
          "move": { "enable": true, "speed": 2 }
        },
        "interactivity": {
          "events": {
            "onhover": { "enable": true, "mode": "grab" },
            "onclick": { "enable": true, "mode": "push" }
          }
        }
      });

      // 2. 动态时间与生日判断
      const now = new Date();
      const year = now.getFullYear();
      const month = now.getMonth() + 1;
      const date = now.getDate();
      const hours = String(now.getHours()).padStart(2, '0');
      const minutes = String(now.getMinutes()).padStart(2, '0');

      let textContent = `现在是${year}年${month}月${date}日 ${hours}:${minutes}`;
      if (month === 3 && date === 11) {
        textContent += " 生日快乐！";
      }
      document.getElementById('dynamic-text').innerText = textContent;

      // 3. 初始化底部随机小字
      initFooterText();
    };

    // ========== 底部随机小字 ==========
    const footerTexts = [
      "下次来的时候，可以跟我说说你最近的小事",
      "要是有什么想让我加在这里的，随时跟我说",
      "对了，要是你刚好是生日当天点开的，那额外祝你：生日快乐，新的一岁，也平平安安，开开心心。"
    ];

    function initFooterText() {
      const randomIndex = Math.floor(Math.random() * footerTexts.length);
      document.getElementById('footerText').innerText = footerTexts[randomIndex];
    }

    // ========== 互动回复语料库 ==========
    const replies = {
      happy: [
        "太棒啦！快说说遇到什么有意思的事了",
        "今天的开心要多存一点，留着慢慢用",
        "真好，你开心的话，我也跟着开心"
      ],
      chill: [
        "今天有没有喝到好喝的奶茶？",
        "摸鱼快乐！小心别被人抓到啦",
        "要是没什么事，就多陪我待一会儿呗"
      ],
      tired: [
        "不想做的事就先放放，不是必须今天做完",
        "要是不开心，可以和我说说，不用担心打扰",
        "休息一会儿吧，你已经做得够多了"
      ],
      struggle: [
        "不用事事都做到完美，不完美也没关系",
        "不管做的正确与否，你的行为都是很可爱的小事",
        "说不出话也没关系，好好缓缓放空"
      ]
    };

    // ========== 滚动监听：第二屏元素出现动画 ==========
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const buttons = document.querySelectorAll('.option-btn');
          buttons.forEach((btn, index) => {
            setTimeout(() => {
              btn.classList.add('visible');
              btn.style.transition = `all 0.6s ease-out ${index * 0.15}s`;
            }, 100);
          });
          observer.unobserve(entry.target);
        }
      });
    }, { threshold: 0.2 });

    observer.observe(document.getElementById('interaction'));

    // ========== 按钮点击交互 ==========
    document.querySelectorAll('.option-btn').forEach(btn => {
      btn.addEventListener('click', function () {
        const type = this.getAttribute('data-type');
        const optionsContainer = document.getElementById('optionsContainer');
        const replyContainer = document.getElementById('replyContainer');
        const replyText = document.getElementById('replyText');

        // 1. 隐藏选项
        optionsContainer.classList.add('hide');

        // 2. 随机选择回复
        const replyList = replies[type];
        const randomReply = replyList[Math.floor(Math.random() * replyList.length)];
        replyText.innerText = randomReply;

        // 3. 显示回复
        setTimeout(() => {
          replyContainer.classList.add('show');
        }, 300);
      });
    });
  </script>
</body>

</html>